package ai.yunxi.string;

/**
 * 拼接所有字符串产生字典顺序最小的大写字符串
 * 给定一个字符串类型的数组str，请找到一种拼接顺序，使得将所有字符串拼接起来
 * 组成的大写字符串是所有可能性中顺序最小的，返回这个大写字符串
 * 举例：
 * 1.str=["ab","d"]，可以拼接成"abd"和"dab"，但前者的字典顺序更小，所以返回"abd"
 * 2.str=["b","ba"]，可以拼接成"bba"和"bab"，后者的字典顺序更小，所以返回"bab"
 * <p>
 * 有一种思路为：
 * 先把str中的所有字符串按照字典顺序排列，然后将串起来的结果返回，这么做的结果是错误的。
 * 比如例子中的2，按字典顺序排列的结果是"b"、"ba"，但拼接后的结果"bba"并不是字典顺序最小的。
 * <p>
 * 真正的拼接思路：
 * 假设有两个字符串，分别记为a、b，a和b拼接起来的字符串用a.b表示。如果a.b的字典顺序小于b.a，
 * 就把字符串a放前面、b放后面，否则将他们反过来放。每两个字符串之间都按这个标准进行比较，
 * 以此标准排序后，再依次串起来的大写字符串就是结果。
 * 这样做为什么是对的呢？需要证明。关键在于证明这种排序方式具有传递性：
 * 假设有a、b、c三个字符串，它们有如下关系：
 * a.b < b.a
 * b.c < c.b
 * 则需要证明a.c < c.a
 * <p>
 * 证明过程如下：
 * 字符串的在本质上可以看做K进制数，比如十六进制就能看做由0~9的10个数字和a、b、c、d、e、f组成的字符串
 * 那么拼接后的字符串a.b可以看做a这个数作为它的高位，b作为低位，则它的值a.b=a*(K^b的长度)+b。
 * 举一个十进制的例子，a=123，b=6789，那么拼接后的a.b=1236789，也可以通过公式计算得出，
 * K=10，b的长度=4，10^4=10000，则a.b=123*10000+6789=1236789。、
 * 为了证明过程便于阅读，我们把(K^b的长度)记为k(b)，则原来的不等可变为：
 * a.b < b.a => a*k(b) + b < b*k(a) + a
 * b.c < c.b => b*k(c) + c < c*k(b) + b
 * 现在要证明a.c < c.a，即a*k(c) + c < c*k(a) + a
 * <p>
 * 已知的两个不等式里都含有k(b)，考虑通过k(b)进行不等式传递
 * 把第一个不等式两边同时减去b，再乘以c：a*k(b)*c < b*k(a)*c + a*c - b*c
 * 再把第二个不等式两边同时减去b，再乘以a：b*k(c)*a + c*a - b*a < c*k(b)*a
 * 因为a、b、c都是K进制数，符合乘法交换律，有a*k(b)*c = c*k(b)*a，则可得出下面的不等式：
 * b*k(c)*a + c*a - b*a < c*k(b)*a < b*k(a)*c + a*c - b*c
 * => b*k(c)*a + c*a - b*a < b*k(a)*c + a*c - b*c
 * => b*k(c)*a - b*a < b*k(a)*c - b*c
 * => k(c)*a - a < k(a)*c - c
 * => a*k(c) + c < c*k(a) + a
 * 即a.c < c.a，传递性证明完毕
 * <p>
 * 传递性证明完毕后，我们还需要证明，按上述过程排序后的字符串数组，拼接成的字符串，是所有拼接中字典顺序最小的，
 * 也即是任意交换这种拼接中两个字符串的位置，得到的新字符串的字典顺序都比原来要大。
 * 假设有任意一个排序后拼接成的字符串，我们要交换其中某两个字符串的位置，这两个交换的字符串分别记为A和L，
 * A和L中间有n(n>=0)个字符串，分别记为M(1)、M(2)、... 、M(n-1)、M(n)，
 * 则这个拼接字符串可以表示为：...A.M(1).M(2)...M(n-1).M(n).L...
 * 交换A和L后的字符串为：...L.M(1).M(2)...M(n-1).M(n).A...
 * <p>
 * 1.根据排序的定义，如果a.b < b.a，则把a排在前面，那么M(1)排在L前面，则有M(1).L < L.M(1)，
 * 那么进一步有：...L.M(1).M(2)...M(n-1).M(n).A... > ...M(1).L.M(2)...M(n-1).M(n).A...
 * 同理M(2)排在L前面，则有M(2).L < L.M(2)，
 * 进一步有：...M(1).L.M(2)...M(n-1).M(n).A... > ...M(1).M(2).L...M(n-1).M(n).A...
 * ......
 * M(n)排在L前面，则有M(n).L < L.M(n)，
 * 进一步有：...M(1).M(2)...M(n-1).L.M(n).A... > ...M(1).M(2)...M(n-1).M(n).L.A...
 * A排在L前面，有A.L < L.A
 * 进一步有：...M(1).M(2)...M(n-1).M(n).L.A... > ...M(1).M(2)...M(n-1).M(n).A.L...
 * 综合以上不等式的传递性，我们最终得到：...L.M(1).M(2)...M(n-1).M(n).A... > ...M(1).M(2)...M(n-1).M(n).A.L...
 * <p>
 * 2.同理根据A排在M(n)前面，有A.M(n) < M(n).A，
 * 进一步有：...M(1).M(2)...M(n-1).M(n).A.L... > ...M(1).M(2)...M(n-1).A.M(n).L...
 * A排在M(n-1)前面，有A.M(n-1) < M(n-1).A，
 * 进一步有：...M(1).M(2)...M(n-1).A.M(n).L... > ...M(1).M(2)...A.M(n-1).M(n).L...
 * ......
 * A排在M(1)前面，有A.M(1) < M(1).A，
 * 进一步有：...M(1).A.M(2)...M(n-1).M(n).L... > ...A.M(1).M(2)...M(n-1).M(n).L...
 * 然后最终得到：...M(1).M(2)...M(n-1).M(n).A.L... > ...A.M(1).M(2)...M(n-1).M(n).L...
 * <p>
 * 所以根据上面1、2的结果，我们得到：...L.M(1).M(2)...M(n-1).M(n).A... > ...A.M(1).M(2)...M(n-1).M(n).L...
 * 交换任意字符串A和L位置的结果，字典顺序都要大于交换之前，因此上述排列拼接得到的字符串就是字典顺序最小的
 * <p>
 * 整个问题的求解，就变成了对整个字符串数组，按上述规则对数组进行排序，可以参照插入排序的逻辑。
 * 插入排序的时间复杂度最小可以达到O(N*logN)。本次给出的解法是直接插入排序，时间复杂度O(N*N)
 */
public class SpliceString {

    public String lowestString(String[] str) {
        if (str == null || str.length == 0) return "";
        // 按上面的逻辑排序
        insertSort(str);
        // 拼接最后的字符串
        return String.join("", str);
    }

    // 直接插入排序
    private void insertSort(String[] str) {
        for (int i = 1; i < str.length; i++) {
            // 对于每个位置i的字符串str[i]，都要和前0~i-1的字符串比较
            String temp = str[i];
            int j;
            for (j = i - 1; j >= 0; j--) {
                int res = compare(str[j], temp);
                if (res <= 0) {
                    // 若str[j].temp < temp.str[j]，str[j]在前，temp放在str[j]之后
                    // 若相等，则谁在前都可以，这里同样选择temp放在str[j]之后
                    // 根据这个排序的传递性，有str[j-1].str[j] < str[j].str[j-1]和str[j].temp < temp.str[j]
                    // 那么必然有str[j-1].temp < temp.str[j-1]，temp也应该在str[j-1]之后
                    // 依次往前推，temp应该在全部str[0~j]之后，所以temp的位置找到了，就是j+1，直接结束循环
                    break;
                } else {
                    // 若str[j].temp > temp.str[j]，temp应该在str[j]之前，因此str[j]向后移动一位，继续下一次循环
                    str[j + 1] = str[j];
                }
            }
            // 把位置j+1设为temp
            str[j + 1] = temp;
        }
    }

    // 比较两个字符串的逻辑，如果a.b < b.a，那么a在前，返回-1，反之返回1，相等返回0
    private int compare(String a, String b) {
        return (a + b).compareTo(b + a);
    }

    public static void main(String[] args) {
        SpliceString string = new SpliceString();
        String[] str = {"b", "ba", "bcd"};
        System.out.println(string.lowestString(str));
    }
}
